;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Type structures
;;
;; type  ::= (box (C k:symbol f:flag a:(list type) n:type))
;;         | (box (V name:num kind:symbol depth:num inst:(list type))
;;         | (box  type)
;; flag  ::= (box (V name:num kind:symbol depth:num inst:(list type))
;;         | 'Top
;;         | (box  flag)
;;
;; The "depth" field is a number representing the outermost
;; environment variables may appear in; smaller numbers indicate
;; more outer environments, the global environment is ord-depth.
;;
;; For generalized variables (depth > nongen-depth),
;;   bit 0 of name indicates "visible" (not useless);
;;   bits 1,2 are reserved.

(define-structure (C kind pres args next))
(define-structure (V name kind depth inst))
(define-structure (TS depth type))

(define-structure (K name order args))

(define var-counter 8000)
(define make-tvar
  (lambda (k d)
    (set! var-counter (fx+ 8 var-counter))
    (box (make-V var-counter k d #f))))
(define Ord? (lambda (k) (eq? 'Ord k)))
(define Abs? (lambda (k) (eq? 'Abs k)))      ; for procedures
(define Non? (lambda (k) (eq? 'Non k)))      ; for records
(define Pre? (lambda (k) (eq? 'Pre k)))      ; for records
(define Pat? (lambda (k) (eq? 'Pat k)))      ; for temporary use by match

; Variable depths:
(define never-depth 0)
(define mono-depth 1)
(define ord-depth 2)
(define inf-depth 9999)
(define nongen-depth 10000)
(define close-depth 10000)

(define V-ord (lambda (d) (make-tvar 'Ord d)))
(define V-abs (lambda (d) (make-tvar 'Abs d)))
(define V-non (lambda (d) (make-tvar 'Non d)))
(define V-pre (lambda (d) (make-tvar 'Pre d)))
(define V-pat (lambda (d) (make-tvar 'Pat d)))

(define Tvar V-ord)
(define PTvar V-pat)

(define Populated #t) ; switch to control treatment of Abs variables
(define Pseudo #t)    ; switch to control pseudo-subtype

(define Dump-depths #f)

(define pvar
  (match-lambda
    (($ box ($ V name k d _))
     (string->symbol
       (sprintf "~a~a~a"
         (match k
           ('Ord (if (< d nongen-depth)
                     (if (visible-name? name) "Z" "z")
                     (if (visible-name? name) "X" "x")))
           ('Abs (if (visible-name? name) "A" "a"))
           ('Non (if (visible-name? name) "N" "n"))
           ('Pre (if (visible-name? name) "P" "p"))
           ('Pat (if (visible-name? name) "T" "t")))
         (quotient name 8)
         (if Dump-depths
             (sprintf ".~a" d)
             ""))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Misc useful routines

(define make-tvar-like
  (match-lambda
    (($ box ($ V _ k d _)) (make-tvar k d))))

(define ind*
  (lambda (t)
    (recur Lind* ((t t))
      (match t
        (($ box (and i ($ box (? box?)))) (let ((j (Lind* i))) (set-box! t j) j))
        (($ box (and i ($ box (? symbol? ii)))) (set-box! t ii) ii)
        (($ box (and i ($ box _))) (Lind* i))
        (($ box (? symbol? i)) i)
        (_ t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interface routines for dealing with checks

; Is a runtime check caused by this check information?
(define type-check?
  (match-lambda
    ((abs def inexhaust once _)
     (cond (((if once check-abs1? check-abs?) abs)
            (if (and def (definite? def))
                'DEF
                #t))
           (inexhaust 'INEXHAUST)
           (else #f)))))

; Is a runtime check _immediately_ caused by this check information?
(define type-check1?
  (match-lambda
    ((abs def inexhaust _ _)
     (cond ((check-abs1? abs)
            (if (and def (definite? def))
                'DEF
                #t))
           (inexhaust 'INEXHAUST)
           (else #f)))))

; Is a runtime check generated by this variable list?
(define check-abs?
  (lambda (vlist)
    (letrec
      ((seen ())
       (Labs?
        (lambda (t)
          (match t
            (($ box ($ V _ k _ inst))
             (or (Non? k)
                 (and inst (not (memq t seen))
                      (begin
                        (set! seen (cons t seen))
                        (ormap (match-lambda ((t . _) (Labs? t))) inst)))))
            (($ box ($ C _ p _ n))
             (or (Labs? p) (Labs? n)))
            (($ box i)
             (Labs? i))
            (_ #t)))))
      (ormap Labs? vlist))))

; Is a runtime check _immediately_ generated by this variable list?
(define check-abs1?
  (lambda (vlist)
    (letrec
      ((Labs1?
        (lambda (t)
          (match t
            (($ box ($ V _ k _ _))
             (Non? k))
            (($ box ($ C _ p _ n))
             (or (Labs1? p) (Labs1? n)))
            (($ box i)
             (Labs1? i))
            (_ #t)))))
      (ormap Labs1? vlist))))

; Return a set of non-local sources of a check.
(define check-sources
  (lambda (info)
    (letrec
      ((seen ())
       (Lsrcs
        (lambda (t source)
          (match t
            (($ box ($ V _ k _ inst))
             (union
               (if (and (Non? k) source) (set source) empty-set)
               (if (and inst (not (memq t seen)))
                   (begin
                     (set! seen (cons t seen))
                     (foldr union empty-set
                       (map (match-lambda ((t . s) (Lsrcs t s))) inst)))
                   empty-set)))
            (($ box ($ C _ p _ n))
             (union (Lsrcs p source) (Lsrcs n source)))
            (($ box i)
             (Lsrcs i source))
            (_ (if source (set source) empty-set))))))
      (match-let (((abs _ _ _ _) info))
        (if (eq? #t abs)
            empty-set
            (foldr union empty-set
              (map (lambda (t) (Lsrcs t #f)) abs)))))))

; Return a list of local component sources of a check.
(define check-local-sources
  (match-lambda
    ((_ _ _ _ component) component)))

;; Build information about non-absent arguments of a primitive.
;; Returns a value of type:
;;  (MU or (list (+ ty? (cons ty? (cons (list ty?) (cons or nil))))))
(define mk-definite-prim
  (match-lambda
    (($ box ($ C x p a n))
     (if (eq? (K-name x) '->*)
         (let ((seen ()))
           (recur Lprim ((t (car a)))
             (match t
               (($ box ($ C x p a n))
                (if (memq t seen)
                    ()
                    (begin
                      (set! seen (cons t seen))
                      (match (K-name x)
                        ('noarg (cons p (Lprim n)))
                        ('arg (let ((args
                                     (recur argloop ((a (car a)))
                                       (match a
                                         (($ box ($ C _ p _ n))
                                          (cons p (argloop n)))
                                         (($ box ($ V _ k _ _))
                                          (if (Ord? k) (list a) ()))
                                         (($ box i) (argloop i))
                                         (_ ())))))
                                (cons (list p args (Lprim (cadr a)))
                                      (Lprim n))))))))
               (($ box ($ V _ k _ _))
                (if (Ord? k)
                    (list t)
                    ()))
               (($ box i) (Lprim i))
               (_ ()))))
         (mk-definite-prim n)))
    (($ box i) (mk-definite-prim i))
    (_ ())))

(define mk-definite-app
  (match-lambda
    (($ box ($ C x p _ _)) (list p))))

(define mk-definite-lam
  (match-lambda
    (($ box ($ C x p a n))
     (if (eq? (K-name x) '->*)
         (let ((seen ()))
           (recur Llam ((t (car a)))
             (match t
               (($ box ($ C x p a n))
                (if (memq t seen)
                    ()
                    (begin
                      (set! seen (cons t seen))
                      (match (K-name x)
                        ('noarg (cons p (Llam n)))
                        ('arg (let ((args (list 'Top)))
                                (cons (list p args (Llam (cadr a)))
                                      (Llam n))))))))
               (($ box ($ V _ k _ _))
                (if (Ord? k)
                    (list t)
                    ()))
               (($ box i) (Llam i))
               (_ ()))))
         (mk-definite-lam n)))
    (($ box i) (mk-definite-lam i))
    (_ ())))
  

(define definite?
  (lambda (def-info)
    (letrec ((non-empty?
              (lambda (t)
                (let ((seen ()))
                  (recur Ldef ((t t))
                    (match t
                      (($ box ($ C _ p _ n))
                       (or (Ldef p) (Ldef n)))
                      (($ box ($ V _ k d inst))
                       (if (Abs? k)
                           (and (not (memq t seen))
                                (begin
                                  (set! seen (cons t seen))
                                  (and inst
                                       (ormap (match-lambda ((t . _) (Ldef t)))
                                         inst))))
                           (< nongen-depth d)))
                      (($ box i)
                       (Ldef i))
                      ('Top #t))))))
             (ok
              (lambda (l)
                (ormap (match-lambda
                         ((? box? t) (non-empty? t))
                         ((p arg rest) (and (non-empty? p)
                                            (ormap non-empty? arg)
                                            (ok rest))))
                  l))))
      (not (ok def-info)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generalize a type scheme

; Close over type variables of depth at least "depth"
(define close 
  (lambda (t depth)
    (let ((t (if Pseudo (pseudo-subtype t depth) t))
          (seen ()))
      (recur Lclose ((t t))
        (match t
          (($ box ($ C _ p a n))
           (unless (memq t seen)
             (set! seen (cons t seen))
             (Lclose p)
             (for-each Lclose a)
             (Lclose n)))
          (($ box (and x ($ V _ k d _)))
           (unless (memq t seen)
             (set! seen (cons t seen))
             (when (and (<= depth d nongen-depth)
                        (or Populated
                            (or (Ord? k) (Non? k))
                            (= mono-depth depth)))
               (when (and Populated
                          (or (Abs? k) (Pre? k))
                          (not (= mono-depth depth)))
                 (set-V-inst! x ()))
               (set-V-depth! x close-depth))))
          (($ box _) (Lclose (ind* t)))
          ('Top #t)))
      (visible! t close-depth)
      (make-TS close-depth t))))

(define new-close-depth
  (lambda ()
    (set! close-depth (+ 1 close-depth))))

; Close all variables
(define closeall
  (lambda (t)
    (new-close-depth)
    (close t mono-depth)))

(define visible!
  (lambda (t v-depth)
    ;; Renumber generalized type variables to small numbers
    (let ((seen ())(n 8))
      (recur Lsmall ((t t))
        (match t
          (($ box ($ C _ p a n))
           (unless (memq t seen)
             (set! seen (cons t seen))
             (for-each Lsmall a)
             (Lsmall n)))
          (($ box (and x ($ V _ k d _)))
           (unless (memq t seen)
             (set! seen (cons t seen))
             (when (and (= v-depth d) (or (Ord? k) (Pre? k)))
               (set-V-name! x n)
               (set! n (fx+ 8 n)))))
          (($ box i) (Lsmall i))
          ('Top #t))))
    ;; Set visible bit for vars that are not useless.
    (let ((seen ()))
      (recur Lvis ((t t)(pos #t)(rcd #f))
        (match t
          (($ box ($ C x p a n))
           (unless (match (assq t seen)
                     ((_ . valence)
                      (or (element-of? pos (unbox valence))
                          (begin
                            (set-box! valence (union (unbox valence) (set pos)))
                            #f)))
                     (#f (set! seen (cons (cons t (box (set pos))) seen))
                         #f))
             (Lvis p pos rcd)
             (match (K-name x)
               ('->*
                 (Lvis (car a) (not pos) #f)
                 (Lvis (cadr a) pos #f))
               ('record
                 (Lvis (car a) pos #t))
               (_
                (for-each (lambda (x) (Lvis x pos #f)) a)))
             (Lvis n pos rcd)))
          (($ box (and x ($ V name k d _)))
           (when (and (= v-depth d)
                      (or (Ord? k) (Pre? k))
                      (eq? pos rcd)
                      (not (visible-name? name)))
             (set-V-name! x (fx+ 1 name))))
          (($ box i) (Lvis i pos rcd))
          ('Top #t))))
    ))

(define visible-name? odd?)

(define visible?
  (match-lambda
    (($ box ($ V name k _ _)) (or (Pre? k) (visible-name? name)))
    (($ box i) (visible? i))
    ('Top #t)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Instantiate a type scheme, replacing bound type variables by fresh ones.
;;
;; Returns a list consisting of the instantiated type, a list
;; of the new Abs variables, and a list of the new Pre variables

(define instantiate
  (lambda (ts depth syntax)
    (match ts
      (($ TS g-depth t)
       (let*
         ((absv ())
          (seen ())
          (seenv ())
          (t2 (recur Linst ((t t))
                (match t
                  (($ box (and y ($ V _ k d inst)))
                   (if (= d g-depth)
                       (match (assq t seenv)
                         ((_ . new) new)
                         (#f (let ((v (make-tvar k depth)))
                               (when (or (Abs? k) (Pre? k))
                                 (when inst
                                   (set-V-inst! y (cons (cons v syntax) inst)))
                                 (set! absv (cons v absv)))
                               (set! seenv (cons (cons t v) seenv))
                               v)))
                       t))
                  (($ box ($ C x p a n))
                   (match (assq t seen)
                     ((_ . ($ box new)) new)
                     (#f (let* ((fix (box '**FIX**))
                                (fixbox (box fix))
                                (_ (set! seen (cons (cons t fixbox) seen)))
                                (new-p (Linst p))
                                (new-a (map Linst a))
                                (new-n (Linst n)))
                           (if (and (eq? new-p p)
                                    (eq? new-n n)
                                    (andmap eq? new-a a))
                               (begin
                                 (set-box! fixbox t)
                                 t)
                               (begin
                                 (set-box! fix (make-C x new-p new-a new-n))
                                 fix))))))
                  (($ box i) (Linst i))
                  ('Top t)))))
         (list t2 absv))))))

;; Fake subtyping at polymorphic generalization by replacing Tops in
;; negative positions with Ord variables.  Dont touch Tops inside
;; mutable constructors.  Don't unroll recursive types.  Do undo
;; non-recursive sharing if it helps.
;; THIS IS TOO EXPENSIVE!
(define pseudo-subtype2
  (lambda (t depth)
    (let ((recseen ()))
      ;; Determine recursive types and their valences.
      ;; First find a cycle.
      (recur find ((t t)(pos #t)(seen ()))
        (match t
          (($ box ($ C x _ a n))
           (match (memqq t pos seen)
             (#f (let ((seen (cons (cons t pos) seen)))
                   (if (eq? '->* (K-name x))
                       (begin
                         (find (car a) (not pos) seen)
                         (find (cadr a) pos seen))
                       (for-each
                         (lambda (t) (find t pos seen))
                         a))
                   (find n pos seen)))
             (_ ;; Now trace this cycle into recseen.
              (recur trase ((t t)(pos pos))
                (match t
                  (($ box ($ C x _ a n))
                   (unless
                     (match (assq t recseen)
                       (#f (let ((v (box (set pos))))
                             (set! recseen (cons (cons t v) recseen))
                             #f))
                       ((_ . v) (or (element-of? pos (unbox v))
                                    (begin
                                      (set-box! v (union (unbox v) (set pos)))
                                      #f))))
                     (if (eq? '->* (K-name x))
                         (begin
                           (trase (car a) (not pos))
                           (trase (cadr a) pos))
                         (for-each
                           (lambda (t) (trase t pos))
                           a))
                     (trase n pos)))
                  (($ box (? V?)) #f)
                  (($ box i) (trase i pos)))))))
          (($ box (? V?)) #f)
          (($ box i) (find i pos seen))))
      ;; Now copy the type, dropping Top's in - positions outside of
      ;; recursive types to fresh Ord variables, breaking sharing.
      ;; Inside recursive types, don't break sharing.
      (let ((seen ()))
        (recur Lcopy ((t t)(pos #t))
          (match t
            (($ box ($ C x p a n))
             (match (assq t recseen)
               ((_ . ($ box (_ _)))  ; occurs both + and -
                t)
               ((_ . _)
                (match (assq t seen)
                  ((_ . ($ box new)) new)
                  (#f (let* ((fix (box '**FIX**))
                             (fixbox (box fix))
                             (_ (set! seen (cons (cons t fixbox) seen)))
                             (new-p (if (and (not pos) (eq? (ind* p) 'Top))
                                        (V-ord depth)
                                        p))
                             (new-a (if (eq? '->* (K-name x))
                                        (list
                                          (Lcopy (car a) (not pos))
                                          (Lcopy (cadr a) pos))
                                        (map2 (lambda (t m)
                                                (if m
                                                    t
                                                    (Lcopy t pos)))
                                              a (K-args x))))
                             (new-n (Lcopy n pos)))
                        (if (and (eq? new-p p)
                                 (eq? new-n n)
                                 (andmap eq? new-a a))
                            (begin
                              (set-box! fixbox t)
                              t)
                            (begin
                              (set-box! fix (make-C x new-p new-a new-n))
                              fix))))))
               (#f (let* ((new-p (if (and (not pos) (eq? (ind* p) 'Top))
                                     (V-ord depth)
                                     p))
                          (new-a (if (eq? '->* (K-name x))
                                     (list
                                       (Lcopy (car a) (not pos))
                                       (Lcopy (cadr a) pos))
                                     (map2 (lambda (t m)
                                             (if m
                                                 t
                                                 (Lcopy t pos)))
                                           a (K-args x))))
                          (new-n (Lcopy n pos)))
                     (if (and (eq? new-p p)
                              (eq? new-n n)
                              (andmap eq? new-a a))
                         t
                         (box (make-C x new-p new-a new-n)))))))
            (($ box (? V?)) t)
            (($ box i) (Lcopy i pos))))))))

(define memqq
  (lambda (x y l)
    (match l
      (() #f)
      (((a . b) . rest)
       (or (and (eq? a x) (eq? b y)) (memqq x y rest))))))

(define pseudo-subtype
  (lambda (t depth)
    (let ((vlist ())
          (seen ()))
      (recur Lval ((t t)(pos #t)(mutable #f))
        (match t
          (($ box (? V?)) #t)
          (($ box ($ C x p a n))
           (let ((valence
                  (match (assq t vlist)
                    ((_ . v) v)
                    (#f (let ((valence (box empty-set)))
                          (set! vlist (cons (cons t valence) vlist))
                          valence)))))
             (cond
               (mutable
                (set-box! valence (set #t #f)))
               ((not (element-of? pos (unbox valence)))
                (set-box! valence (union (unbox valence) (set pos)))
                (if (eq? '->* (K-name x))
                    (begin
                      (Lval (car a) (not pos) mutable)
                      (Lval (cadr a) pos mutable))
                    (for-each2
                      (lambda (t m)
                        (if m
                            (Lval t pos #t)
                            (Lval t pos mutable)))
                      a (K-args x)))
                (Lval n pos mutable)))))
          (($ box i) (Lval i pos mutable))))
      (recur Lcopy ((t t))
        (match t
          (($ box (? V?)) t)
          (($ box ($ C x p a n))
           (match (assq t seen)
             ((_ . ($ box new)) new)
             (#f (let* ((fix (box '**FIX**))
                        (fixbox (box fix))
                        (_ (set! seen (cons (cons t fixbox) seen)))
                        (new-p (if (and (eq? (ind* p) 'Top)
                                        (match (assq t vlist)
                                          (($ box (#f)) #t)
                                          (_ #f)))
                                   (V-ord depth)
                                   p))
                        (new-a (map Lcopy a))
                        (new-n (Lcopy n)))
                   (if (and (eq? new-p p)
                            (eq? new-n n)
                            (andmap eq? new-a a))
                       (begin
                         (set-box! fixbox t)
                         t)
                       (begin
                         (set-box! fix (make-C x new-p new-a new-n))
                         fix))))))
          (($ box i) (Lcopy i)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Unification

(define mk-unify
  (lambda (meet bottom)
    (letrec
      ((uni
        (lambda (u v)
          (unless (eq? u v)
            (match (cons u v)
              ((($ box ($ C ux up ua un)) . ($ box ($ C vx vp va vn)))
               (if (eq? ux vx)
                   (begin
                     (set-box! v u)
                     (uni un vn)
                     (for-each2 uni ua va)
                     (uni up vp))
                   (let ((next (make-tvar bottom inf-depth)))
                     (if (K< ux vx)
                         (set-box! v u)
                         (set-box! u v))
                     (uni (box (make-C ux up ua next)) vn)
                     (uni un (box (make-C vx vp va next))))))
              ((($ box (and x ($ V uname uk ud uinst))) .
                ($ box        ($ V vname vk vd vinst)))
;               (set-V-name! x (fxlogor uname (fxlogand vname 7)))
               (set-V-kind! x (meet uk vk))
               (set-V-depth! x (min ud vd))
               (set-box! v u))
              ((($ box (? V? x)) . 'Top)
               (uni v u))
              (('Top . ($ box (? V? x)))
               (set-box! v u))
              ((($ box ($ V _ k d _)) . ($ box (? C?)))
               (restrict! v u)
               (set-box! u v))
              ((($ box (? C?)) . ($ box ($ V _ k d _)))
               (restrict! u v)
               (set-box! v u))
              (_
               (uni (ind* u) (ind* v)))))))
       (restrict!
        (lambda (t v)
          (match v
            (($ box ($ V _ k d _))
             (let ((seen ()))
               (recur Lrestrict ((t t)(k k))
                 (match t
                   (($ box (and x ($ V _ vk vd _)))
                    (set-V-kind! x (meet k vk))
                    (set-V-depth! x (min d vd)))
                   (($ box ($ C _ p a n))
                    (unless (memq t seen)
                      (set! seen (cons t seen))
                      (Lrestrict p k)
                      (Lrestrict n k)
                      (for-each
                        (if #t ; (Pat? k)  ; see ex/flatten.ss
                            (lambda (x) (Lrestrict x k))
                            (lambda (x) (Lrestrict x bottom)))
                        a)))
                   (($ box i) (Lrestrict i k))
                   ('Top #f)))))))))
      uni)))

(define lub        ; lattice:  Ord < Abs < Pat;  Ord < Pre < Non
  (lambda (k1 k2)
    (cond ((Ord? k1) k2)
          ((Ord? k2) k1)
          ((or (Abs? k1) (Pre? k1)) k2)
          ((or (Abs? k2) (Pre? k2)) k1)
          (else k1))))

(define glb        ; lattice:  Pat < Abs < Ord;  Non < Pre < Ord
  (lambda (k1 k2)
    (cond ((Ord? k1) k1)
          ((Ord? k2) k2)
          ((or (Abs? k1) (Pre? k1)) k1)
          ((or (Abs? k2) (Pre? k2)) k2)
          (else k1))))

(define unify (lambda (x y) ((mk-unify lub 'Ord) x y)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Tidy type encoding

;; Grammar:
;;  type  ::= union | tyvar | (MU tyvar type) | bool | (list type) | k
;;  union ::= (+ k ... tyvar) | (+ k ...)

;; Known problems:
;;  1. MU with recursion thru function arg is wrong (pos).
;;  2. MU name is not unbound outside of definition.
;;  3. let pos is wrong, even without recursion.

(define R+-
  (lambda (flag+ flag- tail+- absent- pos depth env type)
    (letrec
      ((absent+ V-ord)
       (tvars ())
       (fvars ())
       (absv ())
       (typevar?
        (lambda (v)
          (and (symbol? v)
               (not (bound? env v))
               (not (memq v '(_ bool MU list arglist + not rec *tidy))))))
       (parse-type
        (lambda (t pos)
          (match t
            (('MU a t)
             (unless (typevar? a)
               (raise 'type "invalid type syntax at ~a" t))
             (when (assq a tvars)
               (raise 'type "~a is defined more than once" a))
             (let* ((fix (box '**FIX**))
                    (_ (set! tvars (cons (list a fix ()) tvars)))
                    (t (parse-type t pos)))
               (when (eq? t fix)
                 (raise 'type "recursive type is not contractive"))
               (set-box! fix t)
               (ind* t)))
            (('rec (? list? bind) t2)
             (for-each
               (match-lambda
                 ((a _)
                  (unless (typevar? a)
                    (raise 'type "invalid type syntax at ~a" t))
                  (when (assq a tvars)
                    (raise 'type "~a is defined more than once" a))
                  (set! tvars (cons (list a (box '**FIX**) ()) tvars)))
                 (_
                  (raise 'type "invalid type syntax at ~a" t)))
               bind)
             (for-each
               (match-lambda
                 ((a t)
                  (match (assq a tvars)
                    ((_ fix _)
                     (let ((t (parse-type t '+-)))
                       (when (eq? t fix)
                         (raise 'type "type is not contractive"))
                       (set-box! fix t))))))
               bind)
             (parse-type t2 pos))
            ('bool
              (parse-type '(+ false true) pos))
            ('s-exp
              (let ((v (gensym)))
                (parse-type `(MU ,v (+ num
                                       nil
                                       false
                                       true
                                       char
                                       sym
                                       str
                                       (vec ,v)
                                       (box ,v)
                                       (cons ,v ,v)))
                  pos)))
            (('list t)
             (let ((u (gensym)))
               (parse-type `(MU ,u (+ nil (cons ,t ,u))) pos)))
            (('arglist t)
             (let ((u (gensym)))
               (parse-type `(MU ,u (+ noarg (arg ,t ,u))) pos)))
            (('+ . (? list? union))
             (parse-union union pos))
            (t
             (parse-union (list t) pos)))))
       (parse-union
        (lambda (t pos)
          (letrec ((sort-cs
                    (lambda (cs)
                      (sort-list cs (lambda (x y) (K< (C-kind x) (C-kind y))))))
                   (link
                    (lambda (c t)
                      (set-C-next! c t)
                      (box c))))
            (recur loop ((t t)(cs ()))
              (match t
                (()
                 (foldr link
                   (if pos
                       (absent+ depth)
                       (let ((v (absent- depth)))
                         (set! absv (cons v absv))
                         v))
                   (sort-cs cs)))
                (((? box? t))
                 (foldr link
                   t
                   (sort-cs cs)))
                (('_)
                 (foldr link
                   (tail+- depth)
                   (sort-cs cs)))
                (((? symbol? a))
                 (=> fail)
                 (unless (typevar? a) (fail))
                 (let* ((cs (sort-cs cs))
                        (ks (map C-kind cs)))
                   (foldr link
                     (match (assq a tvars)
                       ((_ f aks)
                        (unless (equal? ks aks)
                          (raise 'type "variable ~a is not tidy" a))
                        f)
                       (#f (let ((v (tail+- depth)))
                             (set! tvars (cons (list a v ks) tvars))
                             v)))
                     cs)))
                ((k . rest)
                 (loop rest (cons (parse-k k pos) cs))))))))
       (parse-k
        (lambda (k pos)
          (cond
            ((and (list? k)
                  (let ((n (length k)))
                    (and (<= 2 n) (eq? '-> (list-ref k (- n 2))))))
             (let* ((rk (reverse k))
                    (arg (reverse (cddr rk)))
                    (res (car rk)))
               (letrec ((mkargs (match-lambda
                                  (() 'noarg)
                                  ((x . y) `(arg ,x ,(mkargs y)))
                                  (_ (raise 'type "invalid type syntax")))))
                 (make-C (lookup env '->*)
                   ((if pos flag+ flag-) depth)
                   (let ((a (parse-type (mkargs arg) (flip pos)))
                         (r (parse-type res pos)))
                     (list a r))
                   '**FIX**))))
            (else
             (match k
               ((arg '->* res)
                (make-C (lookup env '->*)
                  ((if pos flag+ flag-) depth)
                  (let ((a (parse-type arg (flip pos)))
                        (r (parse-type res pos)))
                    (list a r))
                  '**FIX**))
               (('record . (? list? fields))
                (make-C (lookup env 'record)
                  ((if pos flag+ flag-) depth)
                  (list
                    (recur loop ((fields fields))
                      (match fields
                        (()
                         ((if pos V-non V-ord) depth))
                        ((((? symbol? f) ftype) . rest)
                         (box
                           (make-C (new-field! f)
                             (if pos
                                 (V-ord depth)
                                 (let ((v (V-pre depth)))
                                   (set! absv (cons v absv))
                                   v))
                             (list (parse-type ftype pos))
                             (loop rest)))))))
                  '**FIX**))
               (('not (? K? k))
                (make-C k
                  (if pos
                      (absent+ depth)
                      (let ((v (absent- depth)))
                        (set! absv (cons v absv))
                        v))
                  (map (lambda (x) (tail+- depth))
                       (K-args k))
                  '**FIX**))
               (('not c)
                (unless (bound? env c)
                  (raise 'type "invalid type syntax at ~a" k))
                (let ((k (lookup env c)))
                  (make-C k
                    (if pos
                        (absent+ depth)
                        (let ((v (absent- depth)))
                          (set! absv (cons v absv))
                          v))
                    (map (lambda (x) (tail+- depth))
                         (K-args k))
                    '**FIX**)))
               (('*tidy c (? symbol? f))
                (unless (bound? env c)
                  (raise 'type "invalid type syntax at ~a" k))
                (let ((k (lookup env c)))
                  (make-C k
                    (match (assq f fvars)
                      ((_ . f) f)
                      (#f (let ((v (tail+- depth))) ; even tho its a flag
                            (set! fvars (cons (cons f v) fvars))
                            v)))
                    (map (lambda (x) (parse-type x pos))
                         (make-list (length (K-args k)) '(+)))
                    '**FIX**)))
               (((? K? k) . (? list? arg))
                (unless (= (length arg) (length (K-args k)))
                  (raise 'type "~a requires ~a arguments"
                    (K-name k) (length (K-args k))))
                (make-C k
                  ((if pos flag+ flag-) depth)
                  (smap (lambda (x) (parse-type x pos)) arg)
                  '**FIX**))
               ((c . (? list? arg))
                (unless (bound? env c)
                  (raise 'type "invalid type syntax at ~a" k))
                (let ((k (lookup env c)))
                  (unless (= (length arg) (length (K-args k)))
                    (raise 'type "~a requires ~a arguments"
                      c (length (K-args k))))
                  (make-C k
                    ((if pos flag+ flag-) depth)
                    (smap (lambda (x) (parse-type x pos)) arg)
                    '**FIX**)))
               (c
                (unless (bound? env c)
                  (raise 'type "invalid type syntax at ~a" k))
                (let ((k (lookup env c)))
                  (unless (= 0 (length (K-args k)))
                    (raise 'type "~a requires ~a arguments"
                      c (length (K-args k))))
                  (make-C k
                    ((if pos flag+ flag-) depth)
                    ()
                    '**FIX**))))))))
       (flip (match-lambda
               ('+- '+-)
               (#t #f)
               (#f #t))))
      (let ((t (parse-type type pos)))
        (list t absv)))))

(define V-top (lambda (_) 'Top))

(define R+   (lambda (d env t) (car (R+- V-top V-ord V-ord V-abs #t d env t))))
(define R-   (lambda (d env t) (car (R+- V-top V-ord V-ord V-abs #f d env t))))
(define R++  (lambda (d env t) (car (R+- V-top V-ord V-ord V-ord #t d env t))))

(define R+collect (lambda (d env t) (R+- V-top V-ord V-ord V-abs #t d env t)))
(define R-collect (lambda (d env t) (R+- V-top V-ord V-ord V-abs #f d env t)))

(define R+pat (lambda (d t)
                (car (R+- V-pat V-pat V-pat V-abs '+- d initial-type-env t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Match typing

(define or-ty (mk-unify lub 'Ord))
(define and-ty (mk-unify glb 'Pat))  ; caution, if we add record patterns

(define R-match
  (lambda (types bindings depth)
    (let* ((t (foldr (lambda (x y) (or-ty x y) y)
                (V-ord depth)
                types)))
      (fix-pat-abs! t)
      (for-each
        (match-lambda ((_ . t) (fix-pat! t #t)))
        bindings)
      (fix-pat! t #t)
      (list t (collect-abs t)))))

(define collect-abs
  (lambda (t)
    (let ((seen ()))
      (recur loop ((t t))
        (match t
          ('Top empty-set)
          (($ box ($ V _ k _ _))
           (if (Abs? k) (set t) empty-set))
          (($ box ($ C _ p a n))
           (if (memq t seen)
               empty-set
               (begin
                 (set! seen (cons t seen))
                 (foldr union (union (loop p) (loop n)) (map loop a)))))
          (($ box i) (loop i)))))))

(define pat-var-bind
  (lambda (t depth)
    (pat-var-bind* t depth #t)))

; Bind a pattern variable by copying a type, sharing Pat variables.
(define pat-var-bind*
  (lambda (t depth how)
    (let ((seen ()))
      (recur loop ((t t))
        (match t
          ('Top (if how 'Top (V-ord depth)))
          (($ box ($ V _ k d _))
           (if (Pat? k)
               t
               (match (assq t seen)
                 ((_ . new) new)
                 (#f (let* ((new (V-ord depth)))
                       (set! seen (cons (cons t new) seen))
                       new)))))
          (($ box ($ C x p a n))
           (match (assq t seen)
             ((_ . new) new)
             (#f (let* ((fix (box '**FIX**))
                        (fixbox (box fix))
                        (_ (set! seen (cons (cons t fixbox) seen)))
                        (new-p (loop p))
                        (new-a (map2 (lambda (mutable a)
                                       (if mutable a (loop a)))
                                     (K-args x)
                                     a))
                        (new-n (loop n)))
                   (if (and #f ; cocks up typing somehow
                            (eq? new-p p)
                            (eq? new-n n)
                            (andmap eq? new-a a))
                       (begin
                         (set-box! fixbox t)
                         t)
                       (begin
                         (set-box! fix (make-C x new-p new-a new-n))
                         fix))))))
          (($ box i) (loop i)))))))

; Set Pat type variables to Ord.  Set Pat flags according to how.
; If how is true, set Pat flags to 'Top, else to Ord.
(define fix-pat!
  (lambda (t how)
    (let ((seen ()))
      (recur loop ((t t))
        (match t
          ('Top 'Top)
          (($ box (and x ($ V _ k _ _)))
           (when (and (Pat? k) (not (eq? 'flags how)))
             (set-V-kind! x 'Ord)))
          (($ box ($ C _ p a n))
           (unless (memq t seen)
             (set! seen (cons t seen))
             (match (ind* p)
               ('Top #t)
               ((and t ($ box ($ V _ k _ _)))
                (when (Pat? k)
                  (if how
                      (set-box! t 'Top)
                      (set-V-kind! (unbox t) 'Ord)))))
             (for-each loop a)
             (loop n)))
          (($ box i) (loop i)))))))

; Set Ord things to Abs.
(define fix-pat-abs!
  (lambda (t)
    (let ((seen ()))
      (recur loop ((t t))
        (match t
          ('Top 'Top)
          (($ box (and x ($ V _ k _ _)))
           (when (Ord? k)
             (set-V-kind! x 'Abs)))
          (($ box ($ C _ p a n))
           (unless (memq t seen)
             (set! seen (cons t seen))
             (loop p)
             (for-each loop a)
             (loop n)))
          (($ box i) (loop i)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Ground types and type constructors
                    
(define fields ())

(define new-field!
  (lambda (x)
    (match (assq x fields)
      (#f (let ((k (make-K
                     x
                     (+ 1 (length fields))
                     '(#f))))
            (set! fields (cons (cons x k) fields))
            k))
      ((_ . k) k))))

(define K<
  (lambda (x y)
    (< (K-order x) (K-order y))))

(define k-counter 0)

(define bind-tycon
  (lambda (x args covers fail-thunk)
    (when (memq x '(_ bool MU list arglist + not rec *tidy))
      (fail-thunk "invalid type constructor ~a" x))
    (set! k-counter (+ 1 k-counter))
    (make-K
      (if covers
          (symbol-append x "." (- k-counter 100))
          x)
      k-counter
      args)))

(define initial-type-env ())

(define init-types!
  (lambda ()
    (set! k-counter 0)
    (set! var-counter 1000)
    (set! initial-type-env
      (foldl
        (lambda (l env)
          (extend-env env (car l)
            (bind-tycon (car l) (cdr l) #f (lambda x (apply disaster 'init x)))))
        empty-env
        initial-type-info))
    (set! k-counter 100)))

(define reinit-types!
  (lambda ()
    (set! var-counter 1000)
    (set! k-counter 100)
    (set! fields ())
    (set-cons-mutability! #t)))

(define initial-type-info
  '((->* #f #f)
    (arg #f #f)
    (noarg)
    (num)
    (nil)
    (false)
    (true)
    (char)
    (sym)
    (str)
    (void)
    (iport)
    (oport)
    (eof)
    (vec #t)
    (box #t)
    (cons #t #t)
    (cvec #f)
    (promise #t)
    (record #f)
    (module #f)))

(define set-cons-mutability!
  (lambda (m)
    (set-K-args! (lookup initial-type-env 'cons) (list m m))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; for debugging

(define tidy?
  (lambda (t)
    (let ((seen ()))
      (recur loop ((t t)(label ()))
        (match t
          (($ box (? V?))
           (match (assq t seen)
             (#f (set! seen (cons (cons t label) seen))
                 #t)
             ((_ . l2) (equal? label l2))))
          (($ box ($ C x _ a n))
           (match (assq t seen)
             ((_ . l2) (equal? label l2))
             (#f (set! seen (cons (cons t label) seen))
                 (and (loop n (sort-list (cons x label) K<))
                      (andmap (lambda (t) (loop t ())) a)))))
          (($ box i)
           (loop i label))
          ('Top
           #t))))))
