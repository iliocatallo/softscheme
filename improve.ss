;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Improve typing by transforming certain shapes of expressions.
;;
;; Someday this should probably use substitutions for efficiency.

(define improve-defs
  (lambda (defs)
    (map (match-lambda
           (($ Define x box-e2)
            (make-Define x (box (improve (unbox box-e2)))))
           (x x))
         defs)))

(define improve
  (match-lambda
    (($ Match e clauses)
     (improve-match e clauses))
    (($ If tst thn els)
     (improve-if tst thn els))
    ((? Var? e)
     e)
    ((? Const? e)
     e)
    (($ Lam args e2)
     (make-Lam args (improve e2)))
    (($ Vlam args rest e2)
     (make-Vlam args rest (improve e2)))
    (($ App (and e1 ($ Var x)) args)
     ; turn (list a b c) into (cons a (cons b (cons c ())))
     (let ((args (map improve args)))
       (if (and (Name-primitive x)
                (eq? (Name-name x) 'list)
                (< (length args) ConsLimit))
           (let ((pcons (lookup initial-env 'cons)))
             (foldr
               (lambda (a rest) (make-App (make-Var pcons) (list a rest)))
               (make-Const () (lookup initial-env 'null?))
               args))
           (make-App e1 args))))
    (($ App e1 args)
     (make-App (improve e1) (map improve args)))
    (($ Begin exps)
     (make-Begin (map improve exps)))
    (($ And exps)
     (make-And (map improve exps)))
    (($ Or exps)
     (make-Or (map improve exps)))
    (($ Delay e2)
     (make-Delay (improve e2)))
    (($ Set! x e2)
     (make-Set! x (improve e2)))
    (($ Let args e2)
     (let ((args (map (match-lambda
                        (($ Bind x e) (make-Bind x (improve e))))
                      args)))
       (make-Let args (improve e2))))
    (($ Let* args e2)
     (let ((args (map (match-lambda
                        (($ Bind x e) (make-Bind x (improve e))))
                      args)))
       (make-Let* args (improve e2))))
    (($ Letr args e2)
     (let ((args (map (match-lambda
                        (($ Bind x e) (make-Bind x (improve e))))
                      args)))
       (make-Letr args (improve e2))))
    (($ Body defs exps)
     (let ((defs (improve-defs defs)))
       (make-Body defs (map improve exps))))
    (($ Record args)
     (make-Record
       (map (match-lambda
              (($ Bind x e) (make-Bind x (improve e))))
            args)))
    (($ Field x e2)
     (make-Field x (improve e2)))
    (($ Cast ty e2)
     (make-Cast ty (improve e2)))))

(define improve-if
  ; Recognize certain kinds of ifs, and translate into match.
  ; This works together with improve-match, which adds "and" patterns
  ; for matches of variables.
  (lambda (tst thn els)
    (let ((if->match
            (lambda (x p mk-s thn els)
              (make-Match (make-Var x)
                (list
                  (make-Mclause
                    (mk-s (make-Ppred p)) (make-Body () (list thn)) #f)
                  (make-Mclause
                    (mk-s (make-Pany)) (make-Body () (list els)) #f))))))
      (match tst
        (($ App ($ Var v) (e))
         (=> fail)
         (if (and (Name-primitive v) (eq? (Name-name v) 'not))
             (improve-if e els thn)
             (fail)))
        (($ App ($ Var v) (($ Var x)))
         (=> fail)
         (if (and (Name-predicate v) (not (Name-mutated x)))
             (improve
               (if->match x v (lambda (x) x) thn els))
             (fail)))
        (($ App ($ Var v) (($ App ($ Var s) (($ Var x)))))
         (=> fail)
         (if (and (Name-predicate v) (Name-selector s) (not (Name-mutated x)))
             (improve
               (if->match x v (Name-selector s) thn els))
             (fail)))
        (($ App ($ Var v) (($ Var x)))
         (=> fail)
         (if (and (Name-selector v) (not (Name-mutated x)))
             (let ((p (lookup initial-env 'false-object?)))
               (improve
                 (if->match x p (Name-selector v) els thn)))
             (fail)))
        (($ Var v)
         (=> fail)
         (if (not (Name-mutated v))
             (let ((p (lookup initial-env 'false-object?)))
               (improve
                 (if->match v p (lambda (x) x) els thn)))
             (fail)))
        (_ (make-If (improve tst) (improve thn) (improve els)))))))

(define improve-match
  (lambda (e clauses)
    (let ((clauses
           (map (match-lambda
                  (($ Mclause p body fail)
                   (make-Mclause p (improve body) fail)))
                clauses)))
      (match e
        (($ Var x)
         (if (not (Name-mutated x))
             (let ((fix-clause
                    (match-lambda
                      ((and c ($ Mclause p e fail))
                       (if (not (uses-x? e x))
                           c
                           (let ((y (rebind-var x)))
                             (make-Mclause
                               (make-flat-Pand (list p (make-Pvar y)))
                               (sub e x y)
                               fail)))))))
               (make-Match e (map fix-clause clauses)))
             (make-Match e clauses)))
        (_ (make-Match (improve e) clauses))))))

(define uses-x?
  (lambda (e x)
    (recur loop ((e e))
      (match e
        (($ And exps)
         (ormap loop exps))
        (($ App fun args)
         (or (loop fun) (ormap loop args)))
        (($ Begin exps)
         (ormap loop exps))
        (($ If e1 e2 e3)
         (or (loop e1) (loop e2) (loop e3)))
        (($ Lam names body)
         (loop body))
        (($ Let bindings body)
         (or (ormap (match-lambda (($ Bind _ b) (loop b))) bindings)
             (loop body)))
        (($ Let* bindings body)
         (or (ormap (match-lambda (($ Bind _ b) (loop b))) bindings)
             (loop body)))
        (($ Letr bindings body)
         (or (ormap (match-lambda (($ Bind _ b) (loop b))) bindings)
             (loop body)))
        (($ Or exps)
         (ormap loop exps))
        (($ Delay e2)
         (loop e2))
        (($ Set! name exp)
         (or (eq? x name) (loop exp)))
        (($ Var name)
         (eq? x name))
        (($ Vlam names name body)
         (loop body))
        (($ Match exp clauses)
         (or (loop exp)
             (ormap (match-lambda (($ Mclause p b _) (or (loop p) (loop b))))
               clauses)))
        (($ Body defs exps)
         (or (ormap loop defs) (ormap loop exps)))
        (($ Record bindings)
         (ormap (match-lambda (($ Bind _ b) (loop b))) bindings))
        (($ Field _ e)
         (loop e))
        (($ Cast _ e)
         (loop e))
        (($ Define _ box-e)
         (loop (unbox box-e)))
        ((? Defstruct?)
         #f)
        ((? Datatype?)
         #f)
        (($ Pand pats)
         (ormap loop pats))
        (($ Pnot pat)
         (loop pat))
        (($ Pobj c args)
         (ormap loop args))
        (($ Ppred pred)
         (eq? x pred))
        (_ #f)))))

(define sub
  ; Replace uses of x with to in e
  (lambda (e x to)
    (let ((doS (lambda (y) (if (eq? x y) to y))))
      (recur sub ((e e))
        (match e
          (($ Define x box-e)
           (make-Define x (box (sub (unbox box-e)))))
          ((? Defstruct?)
           e)
          ((? Datatype?)
           e)
          (($ Match e clauses)
           (let ((clauses (map (match-lambda
                                 (($ Mclause p e fail)
                                  (make-Mclause p (sub e) fail)))
                               clauses)))
             (make-Match (sub e) clauses)))
          (($ If tst thn els)
           (make-If (sub tst) (sub thn) (sub els)))
          (($ Var x)
           (make-Var (doS x)))
          ((? Const? e)
           e)
          (($ Lam args e2)
           (make-Lam args (sub e2)))
          (($ Vlam args rest e2)
           (make-Vlam args rest (sub e2)))
          (($ App e1 args)
           (make-App (sub e1) (map sub args)))
          (($ Begin exps)
           (make-Begin (map sub exps)))
          (($ And exps)
           (make-And (map sub exps)))
          (($ Or exps)
           (make-Or (map sub exps)))
          (($ Delay e2)
           (make-Delay (sub e2)))
          (($ Set! x e2)
           (make-Set! (doS x) (sub e2)))
          (($ Let args e2)
           (let ((args (map (match-lambda
                              (($ Bind x e) (make-Bind x (sub e))))
                            args)))
             (make-Let args (sub e2))))
          (($ Let* args e2)
           (let ((args (map (match-lambda
                              (($ Bind x e) (make-Bind x (sub e))))
                            args)))
             (make-Let* args (sub e2))))
          (($ Letr args e2)
           (let ((args (map (match-lambda
                              (($ Bind x e) (make-Bind x (sub e))))
                            args)))
             (make-Letr args (sub e2))))
          (($ Body defs exps)
           (make-Body (map sub defs) (map sub exps)))
          (($ Record args)
           (make-Record
             (map (match-lambda
                    (($ Bind x e) (make-Bind x (sub e))))
                  args)))
          (($ Field x e)
           (make-Field x (sub e)))
          (($ Cast ty e)
           (make-Cast ty (sub e))))))))
