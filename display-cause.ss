;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Routines for displaying the sources of checks.

;; display a summary of checks, with their incorrect types
(define cause
  (lambda ()
    (for-each
      (lambda (def)
        (for-each pretty-print (exp-cause def)))
      tree)))

(define cause*
  (lambda names
    (if (null? names)
        (for-each
          (lambda (def)
            (for-each pretty-print (exp-cause def)))
          tree)
        (for-each
          (match-lambda
            ((? symbol? dname)
             (for-each pretty-print (exp-cause (find-global dname)))))
          names))))

(define exp-cause
  (let ((sum (lambda (exps)
               (foldr (lambda (x y) (append (exp-cause x) y)) () exps)))
        (src (lambda (inf)
               (let ((nonlocal (map tree-index (check-sources inf))))
                 (if (type-check1? inf)
                     (cons (check-local-sources inf) nonlocal)
                     nonlocal)))))
    (match-lambda
      ((and z ($ Type ty ($ Check inf ($ Var x))))
       (if (Name-primitive x)
           (if (type-check? inf)
               (list `((,(symbol-append 'CHECK- (pname x)) ,(tree-index z))
                       ,@(src inf)))
               ())
           (if (type-check1? inf)
               (list `((CLASH ,(pname x) ,(tree-index z))
                       ,@(src inf)))
               ())))
      ((and z ($ Type ty ($ Check inf ($ Lam x e1))))
       (append
         (if (type-check? inf)
             (list `((CHECK-lambda ,(tree-index z) ,(map pname x) ...)
                     ,@(src inf)))
             ())
         (exp-cause e1)))
      ((and z ($ Type ty ($ Check inf ($ Vlam x rest e1))))
       (append
         (if (type-check? inf)
             (list `((CHECK-lambda ,(tree-index z)
                       ,(append (map pname x) (pname rest)) ...)
                     ,@(src inf)))
             ())
         (exp-cause e1)))
      ((and z ($ Type _ ($ Check inf ($ App e1 args))))
       (append
         (if (type-check? inf)
             (list `((CHECK-ap ,(tree-index z))
                     ,@(src inf)))
             ())
         (exp-cause e1)
         (sum args)))
      ((and z ($ Type _ ($ Check inf ($ Field x e1))))
       (append
         (if (type-check? inf)
             (list `((CHECK-field ,(tree-index z) ,x ...)
                     ,@(src inf)))
             ())
         (exp-cause e1)))
      ((and z ($ Type _ ($ Check inf ($ Cast (x . _) e1))))
       (append
         (if (type-check? inf)
             (list `((CHECK-: ,(tree-index z) ,x ...)
                     ,@(src inf)))
             ())
         (exp-cause e1)))
      ((and z ($ Type _ ($ Check inf (and m ($ Match e1 clauses)))))
       (append
         (if (type-check? inf)
             (list `((CHECK-match ,(tree-index z) ...)
                     ,@(src inf)))
             ())
         (exp-cause m)))
      (($ Define _ ($ box e))
       (exp-cause e))
      ((? Defstruct?)
       ())
      ((? Datatype?)
       ())
      (($ App e1 args)
       (sum (cons e1 args)))
      (($ Match exp clauses)
       (foldr (lambda (x y)
                (append (match x (($ Mclause _ e _) (exp-cause e))) y))
         (exp-cause exp)
         clauses))
      (($ Var _)
       ())
      (($ And exps)
       (sum exps))
      (($ Begin exps)
       (sum exps))
      ((? Const?)
       ())
      (($ If test then els)
       (append
         (exp-cause test)
         (exp-cause then)
         (exp-cause els)))
      (($ Let bindings body)
       (foldr (lambda (x y)
                (append (match x (($ Bind _ e) (exp-cause e))) y))
         (exp-cause body)
         bindings))
      (($ Let* bindings body)
       (foldr (lambda (x y)
                (append (match x (($ Bind _ e) (exp-cause e))) y))
         (exp-cause body)
         bindings))
      (($ Letr bindings body)
       (foldr (lambda (x y)
                (append (match x (($ Bind _ e) (exp-cause e))) y))
         (exp-cause body)
         bindings))
      (($ Body defs exps)
       (sum (append defs exps)))
      (($ Or exps)
       (sum exps))
      (($ Delay e)
       (exp-cause e))
      (($ Set! var body)
       (exp-cause body))
      (($ Record bindings)
       (foldr (lambda (x y)
                (append (match x (($ Bind _ e) (exp-cause e))) y))
         ()
         bindings))
      (($ Type _ exp)
       (exp-cause exp)))))
