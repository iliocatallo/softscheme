;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Routines for displaying checks

(define check
  (lambda (file)
    (output-checked file #f type-check?)))

(define profcheck
  (lambda (file)
    (output-checked file #t type-check?)))

(define fullcheck
  (lambda (file)
    (output-checked file #t (lambda (_) #t))))

(define output-checked
  (lambda (file profile check-test)
    (let ((doit (lambda ()
                  (when file
                    (printf ";; Generated by Soft Scheme ~a~%" soft:version)
                    (unless (= 0 n-unbound)
                      (printf ";; CAUTION: ~a unbound references, this code may not be safe~%" n-unbound))
                    (summary "; ")
                    (printf "~%"))
                  (when profile
                    (profiling-code check-test))
                  (for-each
                    (lambda (exp)
                      (pretty-print (expcheck exp check-test)))
                    tree))))
      (if file
          (begin
            (delete-file file)
            (with-output-to-file file doit))
          (doit)))))

(define profiling-code
  (lambda (check-test)
    (pretty-print
      `(define CHECK-COUNTERS
         (make-vector
           ,(foldr + 0
              (map
                (match-lambda
                  (($ Define _ ($ box e))
                   (count-checks e
                     check-test
                     (lambda (_) #t)))
                  (_ 0))
                tree))
           0)))
    (pretty-print
      '(define CHECK-TOTAL
         (lambda ()
           (let ((foldr
                  (lambda (f i l)
                    (recur loop ((l l))
                      (match l
                        (() i)
                        ((x . y) (f x (loop y))))))))
             (foldr + 0 (vector->list CHECK-COUNTERS))))))
    (pretty-print
      '(extend-syntax (CHECK-INCREMENT-COUNTER)
         ((CHECK-INCREMENT-COUNTER c)
          (vector-set! CHECK-COUNTERS c
            (+ 1 (vector-ref CHECK-COUNTERS c))))))))

(define summary
  (lambda (hdr)
    (let* ((total 0)
           (def-total 0)
           (typ-total 0)
           (poss-total 0))
      (for-each
        (match-lambda
          (($ Define x ($ box e))
           (let ((n (count-checks e
                      type-check?
                      (lambda (x) (not (eq? 'CLASH x)))))
                 (poss (count-checks e
                         (lambda (_) #t)
                         (lambda (x) (not (eq? x 'CLASH))))))
             (set! poss-total (+ poss-total poss))
             (unless (= 0 n)
               (let ((def (count-checks e
                            (lambda (x) (eq? 'DEF (type-check? x)))
                            (lambda (x) (not (eq? x 'CLASH)))))
                     (mch (count-checks e
                            type-check?
                            (lambda (x) (eq? x 'MATCH))))
                     (inx (count-checks e
                            type-check?
                            (lambda (x) (eq? x 'INEXHAUST))))
                     (prm (count-checks e
                            type-check?
                            (lambda (x) (eq? x 'PRIM))))
                     (lam (count-checks e
                            type-check?
                            (lambda (x) (eq? x 'LAM))))
                     (app (count-checks e
                            type-check?
                            (lambda (x) (eq? x 'APP))))
                     (fld (count-checks e
                            type-check?
                            (lambda (x) (eq? x 'FIELD))))
                     (cst (count-checks e
                            type-check?
                            (lambda (x) (eq? x 'CAST)))))
                 (set! total (+ total n))
                 (set! def-total (+ def-total def))
                 (set! typ-total (+ typ-total cst))
                 (printf "~a~a~a" hdr (padr (pname x) 16) (padl n 2))
                 (when (< 0 (+ inx mch))
                   (if (< 0 inx)
                       (printf " ~s" `(,mch match ,inx inexhaust))
                       (printf " ~s" `(,mch match))))
                 (when (< 0 prm)
                   (printf " (~s prim)" prm))
                 (when (< 0 fld)
                   (printf " (~s field)" fld))
                 (when (< 0 lam)
                   (printf " (~s lambda)" lam))
                 (when (< 0 app)
                   (printf " (~s ap)" app))
                 (when (< 0 def)
                   (printf " (~s ERROR)" def))
                 (when (< 0 cst)
                   (printf " (~s TYPE)" cst))
                 (printf "~%")))))
          (_ #f))
        tree)
      (printf "~a~a~a" hdr (padr "TOTAL CHECKS" 16) (padl total 2))
      (printf " (of ~s is ~s%)"
        poss-total
        (if (= 0 poss-total)
            0
            (string->number
              (chop-number
                (exact->inexact (* (/ total poss-total) 100))
                4))))
      (when (< 0 def-total)
        (printf " (~s ERROR)" def-total))
      (when (< 0 typ-total)
        (printf " (~s TYPE)" typ-total))
      (printf "~%"))))

;; pad on left
(define padl
  (lambda (arg n)
    (let ((s (sprintf "~a" arg)))
      (recur loop ((s s))
        (if (< (string-length s) n)
            (loop (string-append " " s))
            s)))))

;; pad on right
(define padr
  (lambda (arg n)
    (let ((s (sprintf "~a" arg)))
      (recur loop ((s s))
        (if (< (string-length s) n)
            (loop (string-append s " "))
            s)))))

(define chop-number
  (lambda (x n)
    (substring (sprintf "~s00000000000000000000" x) 0 (- n 1))))

(define count-checks
  (lambda (e check-test check-type)
    (letrec
      ((sum
        (lambda (exps)
          (foldr (lambda (x y) (+ (n-checks x) y)) 0 exps)))
       (n-checks
        (match-lambda
          (($ Check inf ($ Var x))
           (if (or
                 (and (Name-primitive x)
                      (check-type 'PRIM)
                      (check-test inf))
                 (and (check-type 'CLASH)
                      (check-test inf)))
               1
               0))
          (($ Check inf (? Lam? z))
           (+ (if (and (check-type 'LAM) (check-test inf)) 1 0)
              (n-checks z)))
          (($ Check inf (? Vlam? z))
           (+ (if (and (check-type 'LAM) (check-test inf)) 1 0)
              (n-checks z)))
          (($ Check inf (? App? z))
           (+ (if (and (check-type 'APP) (check-test inf)) 1 0)
              (n-checks z)))
          (($ Check inf (? Field? z))
           (+ (if (and (check-type 'FIELD) (check-test inf)) 1 0)
              (n-checks z)))
          (($ Check inf (? Cast? z))
           (+ (if (and (check-type 'CAST) (check-test inf)) 1 0)
              (n-checks z)))
          (($ Check inf (? Match? z))
           (+ (if (or (and (check-type 'MATCH)
                           (eq? #t (check-test inf)))
                      (and (check-type 'INEXHAUST)
                           (eq? 'INEXHAUST (check-test inf))))
                  1
                  0)
              (n-checks z)))
          (($ Define _ ($ box e))
           (n-checks e))
          ((? Defstruct?)
           0)
          ((? Datatype?)
           0)
          (($ App fun args)
           (+ (n-checks fun) (sum args)))
          (($ Lam params body)
           (n-checks body))
          (($ Vlam params rest body)
           (n-checks body))
          (($ Field _ e2)
           (n-checks e2))
          (($ Cast _ e2)
           (n-checks e2))
          (($ Var _)
           0)
          (($ Match exp clauses)
           (foldr
             (lambda (x y) (+ y (match x (($ Mclause _ e _) (n-checks e)))))
             (n-checks exp)
             clauses))
          (($ And exps)
           (sum exps))
          (($ Begin exps)
           (sum exps))
          ((? Const?)
           0)
          (($ If test then els)
           (+ (n-checks test) (n-checks then) (n-checks els)))
          (($ Let bindings body)
           (foldr
             (lambda (x y)
               (+ y (match x (($ Bind _ e) (n-checks e)))))
             (n-checks body)
             bindings))
          (($ Let* bindings body)
           (foldr
             (lambda (x y)
               (+ y (match x (($ Bind _ e) (n-checks e)))))
             (n-checks body)
             bindings))
          (($ Letr bindings body)
           (foldr
             (lambda (x y)
               (+ y (match x (($ Bind _ e) (n-checks e)))))
             (n-checks body)
             bindings))
          (($ Body defs exps)
           (+ (sum defs) (sum exps)))
          (($ Record bindings)
           (foldr
             (lambda (x y)
               (+ y (match x (($ Bind _ e) (n-checks e)))))
             0
             bindings))
          (($ Or exps)
           (sum exps))
          (($ Delay exp)
           (n-checks exp))
          (($ Set! _ body)
           (n-checks body))
          (($ Type _ exp)
           (n-checks exp)))))
      (n-checks e))))

(define expcheck
  (lambda (ex check-test)
    (unparse ex
      (lambda (e pexpr)
        (match e
          ((and z ($ Type _ ($ Check inf ($ Var x))))
           (if (Name-primitive x)
               (match (check-test inf)
                 (#f (pname x))
                 ('DEF `(,(symbol-append "CHECK-" (pname x)) ,(tree-index z)
                         ',(string->symbol "ERROR")))
                 (_ `(,(symbol-append "CHECK-" (pname x)) ,(tree-index z))))
               (match (check-test inf)
                 (#f (pname x))
                 (_ `(,(string->symbol "CLASH") ,(pname x) ,(tree-index z))))))
          ((and z ($ Type _ ($ Check inf (and m ($ Lam x e1)))))
           (match (check-test inf)
             (#f (pexpr m))
             ('DEF `(,(string->symbol "CHECK-lambda")
                     (,(tree-index z) ',(string->symbol "ERROR"))
                     ,(map pname x) ,@(pexpr e1)))
             (_ `(,(string->symbol "CHECK-lambda") (,(tree-index z))
                  ,(map pname x) ,@(pexpr e1)))))
          ((and z ($ Type _ ($ Check inf (and m ($ Vlam x rest e1)))))
           (match (check-test inf)
             (#f (pexpr m))
             ('DEF `(,(string->symbol "CHECK-lambda")
                     (,(tree-index z) ',(string->symbol "ERROR"))
                     ,(append (map pname x) (pname rest)) ,@(pexpr e1)))
             (_ `(,(string->symbol "CHECK-lambda") (,(tree-index z))
                  ,(append (map pname x) (pname rest)) ,@(pexpr e1)))))
          ((and z ($ Type _ ($ Check inf (and m ($ App e1 args)))))
           (match (check-test inf)
             (#f (pexpr m))
             ('DEF `(,(string->symbol "CHECK-ap")
                     (,(tree-index z) ',(string->symbol "ERROR"))
                     ,(pexpr e1) ,@(map pexpr args)))
             (_ (let ((p1 (pexpr e1)))
                  `(,(string->symbol "CHECK-ap") (,(tree-index z))
                    ,p1 ,@(map pexpr args))))))
          ((and z ($ Type _ ($ Check inf (and m ($ Field x e1)))))
           (match (check-test inf)
             (#f (pexpr m))
             ('DEF `(,(string->symbol "CHECK-field")
                     (,(tree-index z) ',(string->symbol "ERROR"))
                     ,x ,(pexpr e1)))
             (_ `(,(string->symbol "CHECK-field") (,(tree-index z))
                  ,x ,(pexpr e1)))))
          ((and z ($ Type _ ($ Check inf (and m ($ Cast (x . _) e1)))))
           (match (check-test inf)
             (#f (pexpr m))
             (_ `(,(string->symbol "CHECK-:") (,(tree-index z))
                  ,x ,(pexpr e1)))))
          ((and z ($ Type _ ($ Check inf (and m ($ Match e1 clauses)))))
           (match (check-test inf)
             (#f (pexpr m))
             (inx (let* ((pclause
                          (match-lambda
                            (($ Mclause p exp fail)
                             (if fail
                                 `(,(ppat p) (=> ,(pname fail)) ,@(pexpr exp))
                                 `(,(ppat p) ,@(pexpr exp))))))
                         (p1 (pexpr e1)))
                    (if (eq? 'INEXHAUST inx)
                        `(,(string->symbol "CHECK-match")
                          (,(tree-index z) ,(string->symbol "INEXHAUST"))
                          ,p1 ,@(mapLR pclause clauses))
                        `(,(string->symbol "CHECK-match")
                          (,(tree-index z))
                          ,p1 ,@(mapLR pclause clauses))))))))))))

(define tree-index-list ())

(define reinit-output!
  (lambda ()
    (set! tree-index-list ())))

(define tree-index
  (lambda (syntax)
    (match (assq syntax tree-index-list)
      (#f (let ((n (length tree-index-list)))
            (set! tree-index-list (cons (cons syntax n) tree-index-list))
            n))
      ((_ . n) n))))

(define tree-unindex
  (lambda (n)
    (let ((max (length tree-index-list)))
      (when (<= max n)
        (use-error "Invalid CHECK number ~a" n))
      (car (list-ref tree-index-list (- max 1 n))))))
